According to the present invention, techniques for setting selected operand fields in pipelined architectures are provided. Methods and systems for efficiently selecting operand fields according to the present invention can be operative on a variety of computer architectures, including RISC architectures..According to the present invention, techniques for setting selected operand fields in pipelined architectures are provided. Methods and systems for efficiently selecting operand fields according to the present invention can be operative on a variety of computer architectures, including RISC architectures..1. A method for performing dependency checking on instructions in a pipeline of a computer system, said pipeline containing a first instruction and subsequent instructions, said instructions comprising an opcode, a first source operand and a second source operand, said instructions comprising monadic instructions and dyadic instructions, said monadic instructions having an opcode that operates only on the first source operand, said dyadic instructions having an opcode that operates on the first source operand and the second source operand, said method comprising:determining if said first instruction comprises a monadic instruction; if said first instruction comprises a monadic instruction, replacing said second source operand with a token; and detecting any dependencies between operands in said first instruction and operands in said subsequent instructions in said pipeline. .2. The method of claim 1 wherein said detecting further comprises:performing dyadic dependency checking for said monadic instructions and said dyadic instructions. .3. The method of claim 1 wherein said token further comprises said first operand..4. The method of claim 1 further comprising:detecting whether said first instruction comprises a floating point instruction; if said first instruction comprises a floating point instruction, using said first operand as said token; otherwise using an integer value as said token. .5. The method of claim 4 further comprising:detecting if a third operand comprises an integer value; and if a third operand comprises an integer value, providing a pre-fetch signal to the cache. .6. The method of claim 1 wherein said instructions comprise RISC instructions..7. A computer system for executing instructions, said instructions comprising a first instruction and subsequent instructions, said instructions comprising an opcode, a first operand and subsequent operands, said instructions comprising monadic instructions and dyadic instructions, said monadic instructions having an opcode that operates only on a first operand, said dyadic instructions having an opcode that operates on a first operand and a second operand, said system comprising:a memory, said memory holding said instructions; a processor, said processor operative to execute said instructions; a pipeline, said pipeline unit operative to control processing by said processor of said instructions retrieved from said memory; wherein said pipeline unit is operatively disposed to: determine if said first instruction comprises a monadic instruction; if said first instruction comprises a monadic instruction, replace said subsequent source operands with a token; and detect any dependencies between operands in said first instruction and operands in said subsequent instructions in said pipeline. .8. The system of claim 7 wherein said detecting further comprises:performing dyadic dependency checking for said monadic instructions and said dyadic instructions. .9. The system of claim 7 wherein said token further comprises said first operand..10. The system of claim 7, wherein said pipeline unit is further operative to:detect whether said first instruction comprises a floating point instruction; if said first instruction comprises a floating point instruction, use said subsequent source operands as said token; otherwise use an integer value as said token. .11. The system of claim 7 wherein said instructions comprise RISC instructions..12. The system of claim 7 further comprising:a 64-bit register which is read-only and returns all zeros. .13. The system of claim 7 wherein said processor is a 64-bit computer processor for executing the instruction stored in memory; wherein said executing comprises one data field using said 64-bit register..14. The computer system of claim 12 wherein said pipeline unit marks said 64-bit register if said 64-bit register is a destination register in said instruction..15. A method for performing dependency checking on computer instructions in a pipeline of a computer system comprising:determining if a first computer instruction, comprising an opcode and a plurality of source operands, has the opcode operating on only a first source operand; replacing a unused operand with the first source operand; and detecting any dependencies between the operands in the first computer instruction and operands in another computer instruction in the pipeline by performing dyadic dependency checking using the unused operand and first source operand. .16. A method for performing dependency checking on computer instructions in a pipeline of a computer system comprising:determining if a first computer instruction, comprising an opcode and a plurality of source operands, has the opcode operating on only a first source operand; replacing a unused operand with a special operand, wherein the special operand references a read-only register comprising zeros; and detecting any dependencies between the operands in the first computer instruction and operands in another computer instruction in the pipeline by performing dyadic dependency checking using the unused operand and first source operand..CROSS-REFERENCES TO RELATED APPLICATIONSThe following applications, including this one, are being filed concurrently, and the disclosure of the other applications are incorporated by reference into this application in their entirety for all purposes:U.S. patent application Ser. No. 09/410,633, entitled “AN INTEGER INSTRUCTION SET ARCHITECTURE AND IMPLEMENTATION”;U.S. patent application Ser. No. 09/690,340, entitled “A METHOD FOR LOADING AND STORING DATA IN A COMPUTER SYSTEM”;U.S. patent application Ser. No. 09/411,600, entitled “A FLOATING POINT INSTRUCTION SET ARCHITECTURE AND IMPLEMENTATION”.U.S. patent application Ser. No. 09,410,675, entitled “A METHOD FOR ENCODING COMPUTER INSTRUCTION DATA FIELD”.BACKGROUND OF THE INVENTIONThe present invention relates generally to computer instruction set architectures, and particularly to the setting of selected operand fields.In the past decade RISC (Reduced Instruction Set Computer) architectures, in which each instruction is ideally performed in a single operational cycle, have become popular. RISC architecture computers present several advantages over standard architecture computers. For instance, RISC instruction sets are capable of much higher data processing speeds due to their ability to perform frequent operations in shorter periods of time. The RISC devices began with 16-bit instruction sets, and grew to 32-bit instruction set architectures.Pipelining techniques have been used in conjunction with RISC architectures to increase data throughput. Pipelining brought the need for data dependency checking; where the output of one instruction is the expected input into a following instruction. In some cases, instructions are divided into monadic (single source) and dyadic (dual source) instructions, each having its own unique dependency logic.In addition to the complexities introduced by pipelining, applications have also contributed to the increasing complexity of RISC architectures. Frequently used constants, such as zero, can be set in different places from different sources.Thus there is need for simplifying dependency logic without adding additional complexities to the hardware. In addition, there is a need to have a centralized, known source for zero to simplify the use of this frequently accessed constant.SUMMARY OF THE INVENTIONAccording to the present invention, techniques for setting selected operand fields in pipelined architectures are provided. Methods and systems for efficiently selecting operand fields according to the present invention can be operative on a variety of computer architectures, including RISC architectures.In a specific embodiment, the present invention provides a method for performing dependency checking on computer instructions in a pipeline of a computer system including determining if a first computer instruction has an opcode operating on only a first source operand. The computer instruction can have an opcode and a plurality of source operands, for example. Next, additional source operands can be replaced with the first source operand or the constant zero operand. Dependencies can be detected between the operands in the computer instruction and operands in other computer instructions in the pipeline. In a present embodiment, detecting can use the dyadic dependency checking for monadic instructions.In another embodiment, the present invention provides a computer system for executing a computer instruction in a pipeline. The system can include a memory containing the computer instruction. The computer instruction can have a plurality of data fields, for example. A register that can return all zeros and a computer processor for executing the computer instruction stored in memory can also be part of the computer system. In a presently preferable embodiment, the register can be a 64-bit read only register, for example. The computer system can place one operand into the register while executing the computer instruction, for example.Numerous advantages are provided by select embodiments according to the present invention. Embodiments can provide for setting selected operand fields in pipelined instructions for select computer architectures. In some embodiments, dependency checking for pipelined instructions can be provided. Many embodiments can be operable with RISC type computer architectures. Select embodiments can provide a standard hardware source for frequently used constant values and the like.These and other advantages and features of the present invention will become apparent to those skilled in this art upon a reading of the following detailed description, which should be taken in conjunction with the accompanying drawings.BRIEF DESCRIPTION OF THE DRAWINGSFIG. 1 illustrates a simplified block diagram of a representative top level partitioning of a core in a specific embodiment of the present invention;FIG. 2 illustrates a simplified block diagram of a representative Instruction Flow Unit in a specific embodiment of the present invention;FIG. 3 illustrates a simplified diagram of a representative computer instruction format in a specific embodiment of the present invention;FIG. 4A illustrates a simplified diagram of a representative pipeline with no data dependency between instructions in a specific embodiment according to the present invention;FIG. 4B illustrates a simplified diagram of a representative pipeline with data dependencies in a specific embodiment of the present invention; andFIG. 4C illustrates a simplified diagram of a representative pipeline with data dependencies causing a stall in a specific embodiment of the present invention.DESCRIPTION OF THE SPECIFIC EMBODIMENTSEmbodiments according to the present invention can provide techniques for setting selected operand fields in pipelined architectures. Methods and systems for efficiently selecting operand fields according to the present invention can be operative on a variety of computer architectures, including RISC architectures.In a specific embodiment, the present invention may be implemented in a CPU having a core unit which may include six units and a detachable Floating-Point Unit (FPU). FIG. 1 illustrates simplified block diagram of a representative top level partitioning of a core of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. Table 1 describes some of the functions of the units illustrated in core 100 of FIG. 1.TABLE 1UnitAcronymDescriptionS5 Core 200S5Top level core blockBus interfaceBIUControls bus access to external modulesunit 205such as peripheral modules and externalmemory interface.InstructionIFUThe front end of the CPU pipe: fetch,Flow Unitdecode, issue & branch. Also contains mode210B emulation.InstructionIMUHandles all integer and multimediamultimediainstructions. The main CPU datapath.unit 220InstructionICUComprises the Instruction Cache and thecache UnitInstruction Translation Lookaside Buffer230(TLB)Load StoreLSUHandles all memory instructions and DataUnit 240cache control.Data cacheDCUComprises the Data Cache and the DataUnit 250Translation Lookaside Buffer (TLB)Floating PointFPUDetachable Floating point unit (not shownUnit 265in FIG. 1).FIG. 2 illustrates a simplified block diagram of an Instruction Fetch Unit (IFU) 210 in a specific embodiment of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. FIG. 2 illustrates instructions entering a Fetch Unit (FE) 242 from an Instruction Cache Unit (ICU) 130. A Decoder (DEC) 244 can identify logical locations of the source and destination operands. Logical locations can include general-purpose register, floating-point register, target address register, control register, embedded immediate constant, the PC, and the like. Decoder 244 can pass its identification information to a Pipeline Control Unit (PPC) 246 that can select the proper source operands from the instructions. The Pipeline Control Unit 246 can also monitor the execution of the instruction through other stages of the instruction pipeline. PPC 246 can ensure that instructions are executed smoothly and correctly, for example. Instructions may be held in the decode stage until all the source operands are ready or can be ready when needed for execution of the instruction. An Operand File (OF) 248 can comprise source registers, i.e., General Purpose Registers (GPR's). Further reference may be had to Appendix 1 for a detailed description of a specific embodiment of IFU 210.FIG. 3 illustrates a simplified diagram of a representative example computer instruction format 260 in a specific embodiment of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. Instruction format 260 is an example of a dyadic instruction including an opcode 262, a register source1264, a register source2268, and a destination register 270. Optionally, an extension 266 to opcode 262 and reserved bits 272 may be provided. In alternative embodiments, source2268 can be replaced by a 6-bit immediate address. Extension 266 and source2268 can be replaced with a 10-bit immediate address. Source1264, extension 266, and source2268 can be replaced with a 16-bit immediate address. FIG. 3 also illustrates a general purpose register 63 (GPR63) 280 which can be a read-only register storing value zero. Any of the source registers 264, 268 or the destination register 270 can be set to GPR63.In a specific embodiment of the present invention, there are two general categories of instructions: the floating-point instructions (or FP instructions) and the rest integer, multimedia, load/store, flow-control instructions (or simply integer instructions). The former operates on floating-point registers, which do not have a constant register, while the later operates on, among others, the general-purpose registers, which has a constant-zero register R63. For FP instructions, all un-used 2nd source operand specifiers, i.e., the contents of the field in the instruction identifying the 2nd source register, may be encoded the same as the 1st source operand specifier so that a generic dependency checking logic can be used to detect instruction dependencies without knowing whether the instruction is monadic or dyadic. For integer instructions, all un-used 2nd source operand specifiers may be encoded as binary “63.” This is because R63 as a constant register has no read-after-write dependency. There can be no writing into R63 and then reading from it. Since this property is true for both monadic and dyadic instructions, forcing all un-used 2nd operand specifiers to be encoded as 63 allows us to use a generic dependency checker on the integer side to check for read-after-write dependencies.In one representative example, general purpose register 63 (GPR63) is used by the instruction PTABS. The PTABS instruction, Table 2, gives a target address specified by the source register Rn. The target address is stored in the target address register TRa. The reserved bits 20-25 may be implemented as “111111” or 63. Thus the hardware for a dyadic dependency checker for read-after write dependencies may be used on PTABS, a monadic instruction.TABLE 2In another representative example, general purpose register 63 (GPR63) is used by the instruction GETTR. This instruction sign-extends a 32-bit target register (TR) into a 64-bit value. Table 3 illustrates a format for a GETTR instruction in a particular embodiment according to the present invention. Execution of a GETTR instruction, moves the value held in a target address register TRb into a general register Rd. The value returned by GETTR ensures that any unimplemented high-order bits of the source target register are seen as sign extensions of the highest implemented bit. Table 3 illustrates a machine code representation of the instruction, followed by an assembly language mnemonic. Next is shown the functional algorithm, which may be implemented in software, hardware, or both.TABLE 3Table 3 illustrates an implementation of the GETTR instruction described in Table 2. In the specific embodiment of Table 3, the GETTR instruction is implemented as an ADD.L with the 2nd operand (Rn=63) being 0 to get the sign-extension. During execution of the ADD.L instruction, the low 32 bits of Rm are added to the low 32 bits of Rn. The sign-extended 32-bit result can be stored in Rd. Thus by having the 2nd source operand specifier, Rn, encoded as 63, the 32-bit sign-extension operation for a monadic instruction, such as GETTR, can be implemented with the same circuit that implements the addition then sign-extension operation for a dyadic instruction, such as ADD.L.TABLE 4In some embodiments, GPR63 can be a read-only register always having all zeroes stored in it. During hazard detection, PPC 246 can check if the current instruction has R63 as a destination. If this is the case, PPC 246 marks the instruction as a non-valid destination. In this way, subsequent instructions may never find hazards on Register 63 and it is read from the register file. This may be further explained, since R63 is a constant register, designating R63 as the target register can not (i) change the value of R63, and (ii) cause dependencies from subsequent instructions that use R63 as a source operand. The specific embodiment of the architecture takes advantage of this property and uses it to provide a prefetch hint to the cache. For example, when a Load instruction is decoded, the IFU checks if the target register is R63 (this logic already exists for the dependency checking). If the target register is R63, the LSU is informed that this is a cache hint and the result will not be used so that the LSU does not need to stall the pipeline if the operand can not be found in the cache. In addition, the LSU will not raise any exception if the load address is bad. Since R63 can not be written into, the load (into R63) will proceed down the pipeline like a NOP except that the cache control is informed to load the operand into the cache if it is not already there.FIG. 4A shows a pipeline with no data dependency between instructions op1310, op2314, and op3318. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. FIG. 4A illustrates instruction op1310 having an opcode, op1, followed by, R1, a position of the first source register (264 in FIG. 3), R2, the position of the second source register (268 in FIG. 3), and R3, the position of the destination register (270 in FIG. 3). The execution timeline 312 illustrates the execution cycle for instruction 310 having op1. Execution timeline 312 has a decode stage, D, and a write stage, W. There are three execution stages in 312, E1, E2, and E3. The next instruction 314 is executed as shown by execution timeline 316. Comparing execution timeline 316 with execution timeline 312, it can be seen that instruction 314 can be decoded, D of 316, while instruction 310 is in execution stage E1 of 312. The arrangement of decode stages (D) in execution timelines 312, 316 and 320 illustrates that a new instruction can be decoded in times i, i+1, and i+2, where each vertical arrangement of blocks in execution timelines 312, 316 and 320, represents the same time cycle. For example at time “i+1” 322, execution cycle 312 is in the E1 stage and execution cycle 316 is in the D stage.FIG. 4B illustrates simplified diagram of a representative pipeline with data dependencies in a specific embodiment of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. FIG. 4B illustrates a first instruction 330 having an opcode op4 and a destination register R3. Destination register R3 is used as a source in subsequent instruction 334, having opcode op5. If the destination data can be produced in one cycle for instruction 330 (op4), then execution timeline 332 shows that at E1, the data is available to the decode cycle, D, of execution timeline 336 for subsequent instruction 334. Similarly, the result of instruction 334 (op5) is produced by execution stage E1 depicted by execution timeline 336. This result is passed to decode stage D, of instruction 338 (op6) illustrated by execution timeline 340.FIG. 4C illustrates a simplified diagram of a representative pipeline with data dependencies causing a stall in a specific embodiment of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. In this example, instruction 350 (op7) takes two execution cycles E1, E2 after decode stage D, as illustrated by execution timeline 352. The R3 result of instruction 350 is used as an input to instruction 354 (op8). Therefore, the PPC “stalls” one cycle 358 in execution timeline 356, in order to obtain the correct value of R3 from processing of instruction 350 (op7). As instruction 360 (op6) uses result R6 of instruction 354 (op8), processing of this instruction is also delayed, as indicated by execution timeline 362. Thus, in order to prevent a hazard, there may be a data dependency check between the result register R3 of instruction 350 (op7) and the two input source registers R3 and R5 of instruction 354 (op8). Both sources from instruction 354 (op8) may need to be checked, as both source values are required to compute the result R6 of the instruction.In a specific embodiment of the present invention, monadic instructions may have a format such as format of 260 of FIG. 3, with one source register 264 or 268 left unused. If the unused source register were set to be equal to the used source register, then the dependency pipeline diagram illustrated in FIG. 4C could be used. There would not be a need for a separate monadic dependency checking circuit.An example of a monadic instruction with a dyadic format in a specific embodiment of the present invention is the FABS.D instruction. Table 5 illustrates instruction FABS.D, which computes the absolute value of a double-precision floating-point number. It reads the value of DRg, clears its sign bit and stores the result in DRf. The second source register is represented by reserved bits 10-15 or “r1.”TABLE 5Thus setting “r1” in the above instruction to the value of the used source register, DRg, in FABS.D, would allow use of the dyadic dependency checking as described hereinabove with reference to FIG. 4C.Another advantage of the replicated source operand in a monadic instruction may be that this gives more flexibility to the design. In a typical design there will be source operand buses that pass through the pipeline. The replicated source operand allows that source to be accessed on either the source1 or source2 bus to best suit the design. This leads to more flexibility in the physical layout of the design (it may be more physically convenient to take the operand from one bus rather than the other). Also, if the two buses are not equally utilized (i.e., one is loaded more heavily than the other), then the replicated source operand allows the less loaded bus to be used, hence equalizing their loading.CONCLUSIONIn the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. Other embodiments will be apparent to those of ordinary skill in the art. For example, the instructions may be 16 or 64 or 128 bits or more in length, there may be three source operands of which only one is used (hence copied into the other operands), or the pipeline may contain more or less than three stages. Thus it is evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the appended claims and their full scope of equivalents.