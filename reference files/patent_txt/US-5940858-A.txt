For use in an x86-compatible processor having a cache, a circuit and method for setting a size of the cache and a computer system employing the circuit or the method. In one embodiment, the circuit includes: (1) multiple access circuitry dividing the cache into separate physically-addressable sectors and (2) sector disabling circuitry, coupled to the cache, that selectively allows at least one of the sectors to be disabled to decrease the size of the cache..For use in an x86-compatible processor having a cache, a circuit and method for setting a size of the cache and a computer system employing the circuit or the method. In one embodiment, the circuit includes: (1) multiple access circuitry dividing the cache into separate physically-addressable sectors and (2) sector disabling circuitry, coupled to the cache, that selectively allows at least one of the sectors to be disabled to decrease the size of the cache..1. For use in a processor having a cache with a plurality of ways, each way having a plurality of sectors, a circuit for setting a size of said cache, comprising:multiple access circuitry to simultaneously access all of said plurality of sectors within said plurality of ways and then to select one of said plurality of sectors within a selected way; andsector disabling circuitry, coupled to said cache, that selectively allows at least one of said plurality of sectors to be disabled to decrease said size of said cache but without reducing a range of physical addresses for memory locations that can be cached in said cache..2. The circuit as recited in claim 1 wherein said processor translates portions of logical addresses into physical addresses to address said cache, said plurality of sectors individually-addressable as a function of said physical addresses..3. The circuit as recited in claim 2 wherein said plurality of sectors equals two raised to the power of a number of address bits required to be translated to address said cache..4. For use in a processor having a cache with a plurality of ways, each way having a plurality of sectors, a circuit for setting a size of said cache, comprising:means for simultaneously accessing all of said plurality of sectors within said plurality of ways and then selecting one of said plurality of sectors within a selected way; and means, coupled to said cache, for selectively allowing at least one of said plurality of sectors to be disabled to decrease said size of said cache but without reducing a range of physical addresses for memory locations that can be cached in said cache..5. The circuit as recited in claim 4 wherein said processor translates portions of logical addresses into physical addresses to address said cache, said plurality of sectors individually-addressable as a function of said physical addresses..6. The circuit as recited in claim 5 wherein said plurality of sectors equals two raised to the power of a number of address bits required to be translated to address said cache..7. For use in a processor having a cache with a plurality of ways, each way having a plurality of sectors, a method of setting a size of said cache, comprising the steps of:simultaneously accessing all of said plurality of sectors within said plurality of ways and then selecting one of said plurality of sectors within a selected way; andselectively allowing at least one of said plurality of sectors to be disabled to decrease said size of said cache but without reducing a range of physical addresses for memory locations that can be cached in said cache..8. The method as recited in claim 7 further comprising the steps of:translating portions of logical addresses into physical addresses to address said cache; andindividually-addressing said plurality of sectors as a function of said physical addresses..9. The method as recited in claim 8 wherein said plurality of sectors equals two raised to the power of a number of address bits required to be translated to address said cache..10. A computer system, comprising:(a) a pipelined processor having at least one execution pipeline for executing instructions, said execution pipeline including ID (decode), AC (address calculation), and EX (execution) processing stages;(b) system memory for storing data or instructions;(c) a cache with a plurality of ways, each way having a plurality of sectors, for storing portions of said data or ones of said instructions;(d) said processor including fetch logic that fetches said portions of said data or said ones of said instructions from said system memory; and(e) said processor further including a circuit for setting a size of said cache, including:(i) multiple access circuitry simultaneously access all of said plurality of sectors within said plurality of ways and then to select one of said plurality of sectors within a selected way; and(ii) sector disabling circuitry, coupled to said cache, that selectively allows at least one of said plurality of sectors to be disabled to decrease said size of said cache but without reducing a range of physical addresses for memory locations that can be cached in said cache..11. The system as recited in claim 10 wherein said processor translates portions of logical addresses into physical addresses to address said cache, said plurality of sectors individually-addressable as a function of said physical addresses..12. The system as recited in claim 11 wherein said plurality of sectors equals two raised to the power of a number of address bits required to be translated to address said cache..13. A method of operating a computer system, comprising the steps of:(a) applying power to a pipelined processor having at least one execution pipeline for executing instructions, said execution pipeline including ID (decode), AC (address calculation), and EX (execution) processing stages;(b) storing data and instructions in system memory;(c) fetching said data or said instructions from said system memory into a cache with a plurality of ways, each way having a plurality of sectors; and(d) executing said instructions in said processor, said processor further including a circuit for setting a size of said cache and performing steps of:(i) simultaneously accessing all of said plurality of sectors within said plurality of ways and then selecting one of said plurality of sectors within a selected way; and(ii) selectively allowing at least one of said plurality of sectors to be disabled to decrease said size of said cache but without reducing a range of physical addresses for memory locations that can be cached in said cache..14. The method as recited in claim 13 wherein said step of selecting one of said plurality of sectors within a selected way selects one of said plurality of sectors as a function of a value of said address bits required to be translated..15. The method as recited in claim 13 wherein said processor translates portions of logical addresses into physical addresses to address said cache, said plurality of sectors individually-addressable as a function of translated portions of said physical addresses..16. The method as recited in claim 13 wherein said plurality of sectors equals two raised to the power of a number of address bits required to be translated to address said cache..TECHNICAL FIELD OF THE INVENTIONThe present invention is directed, in general, to microprocessors and, more specifically, to microprocessors that implement cache circuits with programmable sizing.CROSS-REFERENCE TO RELATED APPLICATIONSThe present invention is related to that disclosed in:1. U.S. patent application Ser. No. 08/866,565 filed May 30, 1997 entitled "TRANSLATION LOOK-ASIDE BUFFER SLICE CIRCUIT AND METHOD OF OPERATION" and filed concurrently herewith;2. U.S. patent application Ser. No. 08/866,441 filed May 30, 1997 entitled "SHADOW TRANSLATION LOOK-ASIDE BUFFER AND METHOD OF OPERATION" and filed concurrently herewith; and3. U.S. patent application Ser. No. 08/866,691 filed May 30, 1997 entitled "HIT DETERMINATION CIRCUIT FOR SELECTING A DATA SET BASED ON MISS DETERMINATIONS IN OTHER DATA SETS AND METHOD OF OPERATION" and filed concurrently herewith.Each reference is commonly assigned with the present invention and is incorporated herein by reference for all purposes.BACKGROUND OF THE INVENTIONThe ever-growing requirement for high performance computers demands that state-of-the-art microprocessors execute instructions in the minimum amount of time. Over the years, efforts to increase microprocessor speeds have followed different approaches. One approach is to increase the speed of the clock that drives the processor. As the clock rate increases, however, the processor's power consumption and temperature also increase. Increased power consumption increases electrical costs and depletes batteries in portable computers more rapidly, while high circuit temperatures may damage the processor. Furthermore, processor clock speed may not increase beyond a threshold physical speed at which signals may traverse the processor. Simply stated, there is a practical maximum to the clock speed that is acceptable to conventional processors.An alternate approach to improving processor speeds is to reduce the number of clock cycles required to perform a given instruction. Under this approach, instructions will execute faster and overall processor "throughput" will thereby increase, even if the clock speed remains the same. One technique for increasing processor throughput is pipelining, which calls for the processor to be divided into separate processing stages (collectively termed a "pipeline"). Instructions are processed in an "assembly line" fashion in the processing stages. Each processing stage is optimized to perform a particular processing function, thereby causing the processor as a whole to become faster."Superpipelining" extends the pipelining concept further by allowing the simultaneous processing of multiple instructions in the pipeline. Consider, for example, a processor in which each instruction executes in six stages, each stage requiring a single clock cycle to perform its function. Six separate instructions can be processed simultaneously in the pipeline, with the processing of one instruction completed during each clock cycle. Therefore, the instruction throughput of an N stage pipelined architecture is, in theory, N times greater than the throughput of a non-pipelined architecture capable of completing only one instruction every N clock cycles.Another technique for increasing overall processor speed is "superscalar" processing. Superscalar processing calls for multiple instructions to be processed per clock cycle. Assuming that instructions are independent of one another (i.e., the execution of an instruction does not depend upon the execution of any other instruction), processor throughput is increased in proportion to the number of instructions processed per clock cycle ("degree of scalability"). If, for example, a particular processor architecture is superscalar to degree three (i.e., three instructions are processed during each clock cycle), the instruction throughput of the processor is theoretically tripled.One of the most frequently employed techniques for increasing overall processor throughput is to minimize the number of cache misses and to minimize the cache access time in a processor that implements a cache memory. There is a wealth of information describing cache memories and the general theory of operation of cache memories is widely understood. This is particularly true of cache memories implemented in x86 microprocessor architectures. A cache memory is a small but very fast memory that holds a limited number of instructions and data for use by the processor. The lower the cache access time, the faster the processor can run. Also, the lower the cache miss rate, the less often the processor is stalled while the requested data is retrieved from main memory and the higher the processor throughput is. Many techniques have been employed to reduce the access time of cache memories. However, the cache access time is still limited by the rate at which data can be examined in, and retrieved from, the SRAM circuits that are internal to conventional cache memories.Additionally, a failure in an on-board cache memory generally requires that the microprocessor chip be rejected. The larger the cache memory is, the higher the probability that one of the cache memory cells will fail. The relatively high cost of state-of-the-art microprocessors containing large on-board cache memories means that rejecting such a microprocessor results in a significant monetary loss.Therefore, there is a need in the art for improved cache memories that maximize processor throughput. More particularly, there is a need in the art for improved cache memories having a reduced access time. There is a still further need for improved cache memories that are not limited by the rate at which data can be examined and retrieved from the SPAM circuits in the cache memories. Finally, there is a need in the art for fault tolerant cache memories that incorporate redundant structures that allow the cache memory to continue to operate.SUMMARY OF THE INVENTIONTo address the above-discussed deficiencies of the prior art, the present invention provides, for use in an x86-compatible processor having a cache, a circuit and method for setting a size of the cache and a computer system employing the circuit or the method. In one embodiment, the circuit includes: (1) multiple access circuitry dividing the cache into separate physically-addressable sectors and (2) sector disabling circuitry, coupled to the cache, that selectively allows at least one of the sectors to be disabled to decrease the size of the cache.The present invention therefore introduces the broad concept of allowing a cache onboard a processor to be changed in size, perhaps in response to variations brought about during manufacture of the processor.In one embodiment of the present invention, the x-86 processor translates portions of logical addresses into physical addresses to address the cache, the sectors individually-addressable as a function of translated portions of the physical addresses. In an embodiment to be illustrated and described, the translation is performed in a Translation Look-Aside Buffer (TLB). Certain translated bits are employed to select which sectors of the cache contain the requested data or instructions.In one embodiment of the present invention, the cache is divided into a number of sectors equaling two raised to the power of a number of address bits required to be translated to address the cache. In the embodiment to be illustrated and described, two bits, specifically A(13:12), are required to be translated to address the cache. If the cache is divided into four sectors (22), data or instructions may be retrieved from the cache while the bits are being translated, thereby avoiding additional address translation latencies.In one embodiment of the present invention, the circuit further comprises sector selection circuitry that selects one of the sectors as a function of a value of a subset of the address bits required to be translated. The sector selection circuitry may take the form of one or more multiplexers or tri-state buses that employ the translated bits to select the correct sector.The foregoing has outlined, rather broadly, preferred and alternative features of the present invention so that those skilled in the art may better understand the detailed description of the invention that follows. Additional features of the invention will be described hereinafter that form the subject of the claims of the invention. Those skilled in the art should appreciate that they can readily use the disclosed conception and specific embodiment as a basis for designing or modifying other structures for carrying out the same purposes of the present invention. Those skilled in the art should also realize that such equivalent constructions do not depart from the spirit and scope of the invention in its broadest form.BRIEF DESCRIPTION OF THE DRAWINGSFor a more complete understanding of the present invention, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:FIG. 1 is a block diagram of an exemplary system employing a processor in accordance with the principles of the present invention;FIG. 2 is a more detailed block diagram of the processor depicted in FIG. 1, which employs cache line locking in accordance with the principles of the present invention;FIG. 3 is a more detailed block diagram of the pipelined stages of the Integer Unit depicted in FIG. 2;FIGS. 4A and 4B depict a preferred system register set, comprising registers not generally visible to application programmers and typically employed by operating systems and memory management programs;FIG. 5 depicts an exemplary cache unit in accordance with the principles of the present invention;FIG. 6 depicts the exemplary L1 cache in FIG. 2 in greater detail; andFIG. 7 depicts an improved L1 cache divided into sectors according to one embodiment of the present invention.DETAILED DESCRIPTIONThe detailed description of the preferred embodiment for the present invention is organized as follows:1. Exemplary Computing System2. Exemplary Processor2.1 Core2.1.1 The Integer Unit2.1.2 Out-of-Order Processing2.1.3 Pipeline Selection2.1.4 Register Renaming2.1.5 Data Forwarding2.1.5.1 Operand Forwarding2.1.5.2 Result Forwarding2.1.6 Data Bypassing2.1.7 Branch Control2.1.8 Speculative Execution2.1.9 System Register Set2.1.9.1 Model Specific Registers2.1.9.2 Debug Registers2.1.9.3 Test Registers2.1.10 The Floating Point Unit2.2 Cache UnitThis organizational table, and the corresponding headings used in this detailed description, are provided for convenient reference and are not intended to limit the scope of the present invention. It should be understood that while the preferred embodiment is described below with respect to x86 computer architecture, it has general applicability to any architecture. Certain terms related to x86 computer architecture (such as register names, signal nomenclature, etc.), which are known to practitioners in the field of processor design, are not discussed in detail in order not to obscure the disclosure.Moreover, certain structural details, which will be readily apparent to those skilled in the art, having the benefit of the description herein, have been illustrated in the drawings by readily understandable block representations and state/flow diagrams that show and describe details that are pertinent to the present invention. These illustrations do not necessarily represent the physical arrangement of the exemplary system, but are primarily intended to illustrate the major structural components in convenient functional groups, so that the present invention may be more readily understood. It is to be understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.1. EXEMPLARY COMPUTING SYSTEM--FIG. 1 is a block diagram of an exemplary computer system 10 employing a processor in accordance with the principles of the present invention. The exemplary computer system 10 comprises a system circuit board (a.k.a. motherboard) 100 and various peripherals and peripheral interfaces. Motherboard 100 comprises a processor 200 and memory subsystem 400 inter-coupled by a processor P-Bus (sometimes referred to as a CPU or local Bus). System logic circuitry interfaces the processor 200 to three conventional peripheral buses namely: X-Bus, PCI-Bus, and ISA-Bus. For the exemplary computer system, the P-Bus is compliant with the so-called "P55C socket."System logic circuitry comprises a system chipset 601 and a datapath chipset 602 (sometimes referred to as a North-Bridge and South-Bridge, respectively), as well as an external clock source 604 that provides an external clock input to the processor 200 and a system clock signal to the remainder of the motherboard 100. The external clock source 604 may take on many forms without departing from the scope of the present invention, including a digital or analog phase-locked loop or delay line loop circuitry. The exact details are not necessary for understanding the present invention.Processor 200 and the memory subsystem 400 reside on the P-Bus. The only other direct connections to the P-Bus are the system chipset 601 and the datapath chipset 602. According to the exemplary division of system logic functions, the system chipset 601 interfaces to a conventional 32-bit PCI-Bus, while the datapath chipset 602 interfaces to the 16-bit ISA-Bus and the internal 8-bit X-Bus. In alternative embodiments, a special Advanced Graphics Port (AGP) may provide an interface between the P-Bus and a graphics accelerator.Processor 200 is coupled over the P-Bus to L2 (level 2) cache 404 and through data buffers 406 to system memory 402 (DRAM). The system chipset 601 includes control circuitry for the P-Bus, system memory 402, and the L2 cache 404. The datapath chipset 602 also interfaces to the conventional X-Bus. The X-Bus is an internal 8-bit bus that couples to the BIOS ROM 702 and the real-time clock (RTC) 704. In addition, the X-Bus connects to a conventional 8-bit keyboard controller 706.The system and datapath chipsets 601 and 602 provide interface control for the 16-bit ISA-Bus and the 32-bit PCI-Bus. The ISA-Bus maintains compatibility with industry standard peripherals via ISA-compliant peripheral card slots 710. The PCI-Bus provides a higher performance peripheral interface via PCI-compliant peripheral card slots 810 for selected peripherals, such as a video/graphics card 802 and a storage controller 804 (which may be included as part of the system chipset 601) for interfacing to mass storage 906.The motherboard 100 is coupled to external peripherals 900, such as keyboard 902, display 904, and mass storage 906 through the PCI-, ISA-, and X-Buses. Network and modem interconnections are provided as ISA cards, but it is to be understood that they could also be provided as PCI cards.2. EXEMPLARY PROCESSOR--FIG. 2 is a more detailed block diagram of the processor 200 depicted in FIG. 1, which employs cache line locking in accordance with the principles of the present invention. It is to be understood that other forms of the processor 200 may be utilized and other modifications can be made without departing from the scope and spirit of the present invention. The processor 200 consists of four major functional blocks, namely: 1) core 202, 2) cache unit 204, 3) memory management unit (MMU) 206, and 4) bus interface unit (BIU) 208.2.1 CORE--The core 202 comprises a super-pipelined integer unit (IU) 215, a branch target buffer (BTB) 220, and a floating point unit (FPU) 225. The cache unit 204 comprises a 64 Kbyte unified L1 cache 245 that stores the most recently used data and instruction code and a 256 byte instruction line cache 240 that only stores instruction code. The MMU 206 preferably comprises two translation look-aside buffers (TLBs): a main level one (L1) TLB 230 and a larger level two (L2) TLB 235. The L1 TLB 230 is preferably direct mapped and has 16 entries, each entry holding one line of 42 bits. The L2 TLB 235 is preferably 6-way associative and has 384 entries to hold 384 lines.The MMU 206 translates linear (or logical) addresses supplied by the IU 215 into physical addresses, including addresses based on paging, for use by the unified L1 cache 245 and for transmission through the BIU 208. Memory management procedures are preferably x86 compatible, adhering to standard paging mechanisms. The Page Table Entry (PTE) is stored in either the unified L1 cache in the Cache Unit 204, the L2 cache 404, or in system memory 404.The Bus Interface Unit (BIU) provides the P-Bus interface. During a memory cycle, a memory location is selected through the address lines (A31-A3 and BE7#-BE0#) on the P-Bus. Data is passed to/from memory through the data lines (D63-D0) on the P-Bus.The core 202 requests instructions from the cache unit 204. The received integer instructions are decoded by either the X-processing pipeline or Y-processing pipeline within the super-pipelined IU 215. If the instruction is a multimedia extension or FPU instruction, the instruction is passed to the FPU 225 for processing. As required, data is fetched from the 64 Kbyte unified L1 cache 245. If the data is not in the unified L1 cache 245, the data is accessed via the BIU 208 from either the L2 cache 404 or system memory 402.2.1.1 THE INTEGER UNIT--FIG. 3 is a more detailed block diagram of the pipelined stages of the integer unit 215 depicted in FIG. 2. Parallel instruction execution is provided by two seven-stage integer pipelines, referred to as the X-pipeline and the Y-pipeline. Each of the X- and Y-pipelines can process several instructions simultaneously. The IU 215 comprises the following pipeline stages: Instruction Fetch (IF) 301, Instruction Decode 1 (ID1) 302, Instruction Decode 2 (ID2) 303, Address Calculation 1 (AC1) 304, Address Calculation 2 (AC2) 305, Execution 306, and Write-Back 307.The IF 301 stage, shared by both the X- and Y-pipelines, fetches 16 bytes of code from the cache unit 204 in a single clock cycle. Within the IF 301 stage, the code stream is checked for any branch instructions that could affect normal program sequencing. If an unconditional or conditional branch is detected, branch prediction logic within the IF 301 stage generates a predicted target address for the instruction. The IF 301 stage then begins fetching instructions at the predicted address.The super-pipelined Instruction Decode stage comprise the ID1 302 substage and ID2 303 substage. ID1, shared by both X- and Y-pipelines, evaluates the code stream provided by the IF 301 stage and determines the number of bytes in each instruction. Up to two instructions per clock are delivered to the ID2 substages, one in each pipeline.The ID2 303 substage decodes instructions and sends the decoded instructions to either the X- or Y-pipeline for execution. The particular pipeline is chosen, based on which instructions are already in each pipeline and how fast they are expected to flow through the remaining pipe-line stages.The Address Calculation stage comprises the AC1 304 sub-stage and the AC2 305 substage. If the instruction refers to a memory operand, the AC1 substage calculates a linear memory address for the instruction. The AC2 substage performs any required memory management functions, cache accesses, and register file accesses. If a floating point instruction is detected by the AC2 substage, the instruction is sent to the FPU 225 for processing. The Execution 306 stage executes instructions using the operands provided by the address calculation stage. The Write-Back 307 stage stores execution results either to a register file within the IU 215 or to a write buffer in the cache control unit.2.1.2 OUT-OF-ORDER PROCESSING--If an instruction executes faster than the previous instruction in the other pipeline, the instructions may complete out of order. All instructions are processed in order, up to the Execution 306 stage. While in the Execution 306 and Write-Back 307 stages, instructions may be completed out of order. If there is a data dependency between two instructions, hardware interlocks are enforced to ensure correct program execution. Even though instructions may complete out of order, exceptions and writes resulting from the instructions are always issued in program order.2.1.3 PIPELINE SELECTION--In most cases, instructions are processed in either pipeline and without pairing constraints on the instructions. However, certain instructions are preferably processed only in the X-pipeline, such as branch, floating point, and exclusive instructions. Branch and floating point instructions may be paired with a second instruction in the Y-pipeline. Exclusive instructions (e.g., protected mode segment loads, special control, debug, and test register accesses, string instructions, multiply and divide, I/O port accesses, push all and pop all, and inter-segment jumps, calls, and returns), which typically require multiple memory accesses, are preferably not paired with instructions in the Y-pipeline. Although exclusive instructions are not paired, hardware from both pipelines is used to accelerate instruction completion.When two instructions that are executing in parallel require access to the same data or register, one of the following types of data dependencies may occur: Read-After-Write (RAW), Write-After-Read (WAR), and Write-After-Write (WAW). Data dependencies typically force serial execution of instructions. However, the processor 200 employs register renaming, data forwarding, and data bypassing mechanisms that allow parallel execution of instructions containing data dependencies.2.1.4 REGISTER RENAMING--The processor 200 includes a register file containing 32 physical general purpose registers, each of which can be temporarily assigned as one of the general purpose registers defined by the x86 architecture (EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP). For each register write operation, a new physical register is selected to allow previous data to be retained temporarily--effectively removing WAW and WAR dependencies. The programmer does not have to consider register renaming, since register renaming is completely transparent to both the operating system and application software.A WAR dependency exists when the first in a pair of instructions reads a logical register, and the second instruction writes to the same logical register. This type of dependency is illustrated by the pair of instructions shown below. In this and the following examples the original instruction order is shown in parentheses.______________________________________
X-PIPELINE          Y-PIPELINE
______________________________________
(1) MOV BX,AX       (2) ADD AX,CX
BX←AX          AX←AX+CX
______________________________________
In the absence of register renaming, the ADD instruction in the Y-pipeline would have to be stalled to allow the MOV instruction in the X-pipeline to read the AX register. The processor 200, however, can avoid the Y-pipeline stall, as shown below in Table 1. As each instruction executes, the results are placed in new physical registers to avoid the possibility of overwriting a logical register value and to allow the two instructions to complete in parallel (or out of order) rather than in sequence.                                  TABLE 1
__________________________________________________________________________
Register Renaming with WAR Dependency
       Physical Register
       Contents
Instruction
       Reg0
          Reg1
              Reg2
                 Reg3
                     Reg4
                        Pipe
                            Action
__________________________________________________________________________
(Initial)
       AX BX  CX
MOV BX,AX
       AX     CX BX     X   Reg3←Reg0
ADD AX,CX     CX BX  AX Y   Reg4←Reg0+Reg2
__________________________________________________________________________
The representations of the MOV and ADD instructions in the final column of Table 1 are completely independent.A WAW dependency occurs when two consecutive instructions perform write operations to the same logical register. This type of dependency is illustrated by the pair of instructions shown below:______________________________________
X-PIPELINE         Y-PIPELINE
______________________________________
(1) ADD, AX, BX    (2) MOV AX,  mem!
AX←AX+BX      AX← mem!
______________________________________
Without register renaming, the MOV instruction in the Y-pipeline would have to be stalled to guarantee that the ADD instruction in the X-pipeline would first write its results to the AX register. The processor 200, however, can avoid the Y-pipeline stall, as shown below in Table 2. The contents of the AX and DX registers are placed in physical registers. As each instruction executes, the results are placed in new physical registers to avoid the possibility of overwriting a logical register value and to allow the two instructions to complete in parallel (or out of order) rather than in sequence. All subsequent reads of the logical register AX will refer to Reg3, the result of the MOV instruction.                                  TABLE 2
__________________________________________________________________________
Register Renaming with WAW Dependency
        Physical Register
        Contents
Instruction
        Reg0
            Reg1
                Reg2
                    Reg3
                        Pipe
                            Action
__________________________________________________________________________
(Initial)
        AX  BX
ADD AX,BX   BX  AX      X   Reg2←Reg0+Reg1
MOV AX, mem!
            BX      AX  Y   Reg3← mem!
__________________________________________________________________________
2.1.5 DATA-FORWARDING--The processor 200 uses two types of data forwarding in conjunction with register renaming to eliminate RAW dependencies, namely, operand forwarding and result forwarding. Operand forwarding takes place when the first in a pair of instructions performs a move from register or memory, and the data that is read by the first instruction is required by the second instruction. The processor performs the read operation and makes the data read available to both instructions simultaneously. Result forwarding takes place when the first in a pair of instructions performs an operation (such as an ADD) and the result is required by the second instruction to perform a move to a register or memory. The processor 200 performs the required operation and stores the results of the operation to the destination of both instructions simultaneously.2.1.5.1 OPERAND FORWARDING--A RAW dependency occurs when the first in a pair of instructions performs a write, and the second instruction reads the same register. This type of dependency is illustrated by the pair of instructions shown below in the X-and Y-pipelines:______________________________________
X-PIPELINE           Y-PIPELINE
______________________________________
(1) MOV AX,  mem!    (2) ADD BX,AX
AX← mem!        BX←AX+BX
______________________________________
The processor 200, however, can avoid the Y-pipeline stall, as shown below in Table 3. Operand forwarding allows simultaneous execution of both instructions by first reading memory and then making the results available to both pipelines in parallel. Operand forwarding can only occur if the first instruction does not modify its source data. In other words, the instruction is a move type instruction (for example, MOV, POP, LEA). Operand forwarding occurs for both register and memory operands. The size of the first instruction destination and the second instruction source must match.                                  TABLE 3
__________________________________________________________________________
Example of Operand Forwarding
         Physical Register Contents
Instruction
         Reg0
            Reg1
                Reg2
                   Reg3
                       Pipe
                          Action
__________________________________________________________________________
(Initial)
         AX BX
MOV AX,  mem!
            BX  AX     X  Reg2←Reg2+ mem!
MOV AX,  mem!   AX BX  Y  Reg3← mem!+Reg1
__________________________________________________________________________
2.1.5.2 RESULT FORWARDING--A RAW dependency can occur when the first in a pair of instructions performs a write, and the second instruction reads the same register. This dependency is illustrated by the pair of instructions in the X-and Y-pipelines, as shown below:______________________________________
X-PIPELINE         Y-PIPELINE
______________________________________
(1) ADD AX,BX      (2) MOV  mem!,AX
AX←AX+BX       mem!←AX
______________________________________
The processor 200, however, can use result forwarding to avoid the Y-pipeline stall, as shown below in Table 4. Instead of transferring the contents of the AX register to memory, the result of the previous ADD instruction (Reg0+Reg1) is written directly to memory, thereby saving a clock cycle. The second instruction must be a move instruction and the destination of the second instruction may be either a register or memory.              TABLE 4
______________________________________
Result Forwarding Example
        Physical Register Contents
Instruction
          Reg0   Reg1   Reg2 Pipe Action
______________________________________
(Initial) AX     BX
ADD AX,BX        BX     AX   X    Reg2←Reg0+Reg1
MOV  mem!,AX     BX     AX   Y     mem!←Reg0+Reg1
______________________________________
2.1.6 DATA BYPASSING--In addition to register renaming and data forwarding, the processor 200 provides a third data dependency-resolution technique called data bypassing. Data bypassing reduces the performance penalty of those memory data RAW dependencies that cannot be eliminated by data forwarding. Data bypassing is provided when the first in a pair of instructions writes to memory and the second instruction reads the same data from memory. The processor retains the data from the first instruction and passes it to the second instruction, thereby eliminating a memory read cycle. Data bypassing only occurs for cacheable memory locations.A RAW dependency occurs when the first in a pair of instructions performs a write to memory and the second instruction reads the same memory location. This dependency is illustrated by the pair of instructions in the X-and Y-pipelines, as shown below.______________________________________
X-PIPELINE          Y-PIPELINE
______________________________________
(1)ADD  mem!,AX     (2)SUB BX,  mem!
 mem!← mem!+AX BX←BX- mem!
______________________________________
The processor 200 can use data bypassing to stall the Y-pipeline for only one clock cycle by eliminating the Y-pipeline's memory read cycle, as shown below in Table 5. Instead of reading memory in the Y-pipeline, the result of the previous instruction ( mem!+Reg0) is used to subtract from Reg1, thereby saving a memory access cycle.                                  TABLE 5
__________________________________________________________________________
Example of Data Bypassing
        Physical Register Contents
Instruction
        Reg0
            Reg1
                Reg2
                    Pipe
                        Action
__________________________________________________________________________
(Initial)
        AX  BX
ADD  mem!,AX
        AX  BX      X    mem!← mem!+Reg0
SUB BX, mem!
        AX      BX  Y   Reg2←Reg1-{ mem!+Reg0}
__________________________________________________________________________
2.1.7 BRANCH CONTROL--Programmers have found through simulation and experimentation that branch instructions occur on average every four to six instructions in x86-compatible programs. The processor 200 minimizes performance degradation and latency of branch instructions through the use of branch prediction and speculative execution. The processor 200 uses a 512-entry, 4-way set associative Branch Target Buffer (BTB) 220 to store branch target addresses and a 1024-entry branch history table. During the fetch stage, the instruction stream is checked for the presence of branch instructions. If an unconditional branch instruction is encountered, the processor 200 accesses the BTB 220 to check for the branch instruction's target address. If the branch instruction's target address is found in the BTB 220, the processor 200 begins fetching at the target address specified by the BTB 220.In case of conditional branches, the BTB 220 also provides history information to indicate whether the branch is more likely to be taken or not taken. If the conditional branch instruction is found in the BTB 220, the processor 200 begins fetching instructions at the predicted target address. If the conditional branch misses in the BTB 220, the processor 200 predicts that the branch will not be taken, and instruction fetching continues with the next sequential instruction. The decision to fetch the taken or not taken target address is preferably, although not necessarily, based on a four-state branch prediction algorithm.Once fetched, a conditional branch instruction is first decoded and then dispatched to the X-pipeline only. The conditional branch instruction proceeds through the X-pipeline and is then resolved in either the Execution 306 stage or the Write-Back 307 stage. The conditional branch is resolved in the Execution 306 stage if the instruction responsible for setting the condition codes is completed prior to the execution of the branch. If the instruction that sets the condition codes is executed in parallel with the branch, the conditional branch instruction is resolved in the Write-Back 307 stage.Correctly predicted branch instructions execute in a single core clock cycle. If resolution of a branch indicates that a misprediction has occurred, the processor 200 flushes the pipeline and starts fetching from the correct target address. The processor 200 preferably prefetches both the predicted and the non-predicted path for each conditional branch, thereby eliminating the cache access cycle on a misprediction. If the branch is resolved in the Execution 306 stage, the resulting misprediction latency is four clock cycles. If the branch is resolved in the Write-Back 307 stage, the latency is five clock cycles.Since the target address of return (RET) instructions is dynamic rather than static, the processor 200 caches target addresses for RET instructions in an eight-entry return stack rather than in the BTB 220. The return address is pushed on the return stack during a CALL instruction and popped during the corresponding RET instruction.2.1.8 SPECULATIVE EXECUTION--The processor 200 is capable of speculative execution following a floating point instruction or predicted branch. Speculative execution allows the X- and Y-pipelines to continuously execute instructions following a branch without stalling the pipelines waiting for branch resolution. As will be described below, the same mechanism is used to execute floating point instructions in parallel with integer instructions. The processor 200 is capable of up to four levels of speculation (i.e., combinations of four conditional branches and floating point operations). After generating the fetch address using branch prediction, the processor 200 checkpoints the machine state (registers, flags, and processor environment), increments the speculation level counter, and begins operating on the predicted instruction stream.Once the branch instruction is resolved, the processor 200 decreases the speculation level. For a correctly predicted branch, the status of the checkpointed resources is cleared. For a branch misprediction, the processor 200 generates the correct fetch address and uses the checkpointed values to restore the machine state in a single clock. In order to maintain compatibility, writes that result from speculatively executed instructions are not permitted to update the cache or external memory until the appropriate branch is resolved. Speculative execution continues until one of the following conditions occurs: 1) a branch or floating point operation is decoded and the speculation level is already at four; 2) an exception or a fault occurs; 3) the write buffers are full; or 4) an attempt is made to modify a non-checkpointed resource (i.e., segment registers, system flags).2.1.9 SYSTEM REGISTER SET--Registers are broadly grouped into two sets, namely: 1) the application register set comprising registers frequently used by application programs, and 2) the system register set comprising registers typically reserved for use by operating system programs. The application register set preferably includes general purpose registers, segment registers, a flag register, and an instruction pointer register. The system register set preferably includes control registers, system address registers, debug registers, configuration registers, and test registers. In order not to obscure the invention, only relevant portions of the system register set will be further described. Those skilled in the art may easily obtain additional descriptions of the application register set by referring to publications such as "The Cyrix 6x86 Microprocessor Data Book," Order No. 94175-00, August 1995, herein incorporated by reference.FIGS. 4A and 4B depict a preferred system register set 400, comprising registers not generally visible to application programmers and typically employed by operating systems and memory management programs. The control registers, CRO-CR4, control certain aspects of the processor 200 such as paging, coprocessor functions, and segment protection. The debug registers, DR0-DR7, provide debugging facilities to enable the use of data access break-points and code execution breakpoints. The test registers, TR3-TR7, provide a mechanism to test the contents of both the cache unit 204 and the Translation Look-Aside Buffers, TLB 230 and TLB 235. The configuration control registers, CCR0-CCR7, are used to configure the processor 200's on-chip cache operations, power management features, and System Management Mode, as well as provide information on device type and revision.The address region registers, ARR0-ARR7, are used to specify the location and size for the eight address regions. Attributes for each address region are specified in the region control registers, RCR0-RCR7. ARR7 and RCR7 are used to define system main memory and differ from ARR0-ARR6 and RCR0-RCR6. With non-cacheable regions defined on-chip, the processor 200 eliminates data dependencies and resource conflicts in its execution pipelines. If KEN# is active for accesses to regions defined as non-cacheable by the RCRs, the region is not cached.A register index, is used to select one of three bytes in each ARRx. The starting address of the ARRx address region, selected by the START ADDRESS field, must be on a block size boundary. For example, a 128 Kbyte block is allowed to have a starting address of 0 Kbytes, 128 Kbytes, 256 Kbytes, and so on.The region control registers, RCR0-RCR7, specify the attributes associated with the ARRx address regions. Cacheability, weak locking, write gathering, and cache-write-through policies can be activated or deactivated using the attribute bits defined in the region control registers.2.1.9.1 MODEL SPECIFIC REGISTERS--The processor 200 preferably comprises at least four model specific registers (MSRS). The MSRs can be read using the RDMSR instruction. During a register read, the contents of the particular MSR, specified by the ECX register, is loaded into the EDX:EAX registers. The MSR can be written using the WRMSR instruction. During a MSR write the contents of EDX:EAX are loaded into the MSR specified in the register.2.1.9.2 DEBUG REGISTERS--At least six debug registers, DR0-DR3, DR6 and DR7, support debugging on the processor 200. Memory addresses loaded in the debug registers, referred to as "breakpoints," generate a debug exception when a memory access of the specified type occurs to the specified address. A data breakpoint can be specified for a particular kind of memory access, such as a read or a write. Code breakpoints can also be set allowing debug exceptions to occur whenever a given code access (execution) occurs. The size of the debug target can be set to 1, 2, or 4 bytes. The debug registers are accessed via MOV instructions, which can be executed only at privilege level 0. The Debug Address Registers (DR0-DR3) each contain the linear address for one of four possible breakpoints. Each breakpoint is further specified by bits in the Debug Control Register (DR7). For each breakpoint address in DR0-DR3, there are corresponding fields L, R/W, and LEN in DR7 that specify the type of memory access associated with the breakpoint.The R/W field can be used to specify instruction execution as well as data access break-points. Instruction execution breakpoints are always taken before execution of the instruction that matches the breakpoint.The Debug Status Register (DR6) reflects conditions that were in effect at the time the debug exception occurred. The contents of the DR6 register are not automatically cleared by the processor 200 after a debug exception occurs and, therefore, should be cleared by software at the appropriate time. Code execution breakpoints may also be generated by placing the breakpoint instruction (INT 3) at the location where control is to be regained. Additionally, the single-step feature may be enabled by setting the TF flat in the EFLAGS register. This causes the processor to perform a debug exception after the execution of every instruction.2.1.9.3 TEST REGISTERS--The test registers can be used to test the unified L1 cache 245, the L1 TLB 230, and the L2 TLB 235. Test registers TR3, TR4, and TR5 are used to test the unified L1 cache 245 and TR6 and TR7 are used to test the L1 TLB 230 and the L2 TLB 235. Use of these test registers is described in more detail below.2.1.10 FLOATING POINT UNIT--The floating point unit (FPU) 225 processes floating point and multimedia extension instructions and is preferably x87 instruction set compatible, adhering to the IEEE-754 standard. Floating point instructions may execute in parallel with integer instructions. Integer instructions may complete out-of-order with respect to the FPU instructions. The processor 200 maintains x86 compatibility by signaling exceptions and issuing write cycles in program order. Floating point instructions are preferably dispatched to the X-pipeline in the IU 215. The address calculation stage of the X-pipeline checks for memory management exceptions and accesses memory operands used by the FPU 225. If no exceptions are detected, the state of the processor 200 is check-pointed and, during AC2, floating point instructions are dispatched to a FPU instruction queue. The processor 200 can then complete subsequent integer instructions speculatively and out-of-order relative to the FPU instruction and relative to any potential FPU exceptions which may occur.As additional FPU instructions enter the pipeline, the processor 200 can preferably dispatch four or more FPU instructions to the FPU instruction queue. The processor 200 continues executing speculatively and out-of-order, relative to the FPU queue, until one of the conditions that causes speculative execution to halt is encountered. As the FPU 225 completes instructions, the speculation level decreases and the check-pointed resources are available for reuse in subsequent operations. The FPU 225 preferably has a set of six or more write buffers to prevent stalls due to speculative writes.2.2 CACHE UNIT--FIG. 5 depicts an exemplary cache unit 204 in accordance with the principles of the present invention. Those skilled in the art will readily understand that other organizations, sizes and associativities for the cache unit 204 are possible, for which the principles of the present invention may be practiced without departing from the scope of the invention. The cache unit 204 comprises a unified L1 cache 245 and an instruction line cache 240. The unified L1 cache 245 is the primary data cache and secondary instruction cache. The unified L1 cache 245 is preferably, although not exclusively, 64 Kbytes in size and four-way set-associative with a 32 byte line size (2048 lines total).The instruction line cache 240 is the primary instruction cache, provides a high speed instruction stream to the IU 215, and is preferably, though not exclusively, 256 bytes in size and fully associative. The instruction line cache 240 is filled from the unified L1 cache 245 through the data bus. Fetches from the IU 215 that hit in the instruction line cache 240 do not access the unified L1 cache 245. If an instruction line cache miss occurs, the instruction line data from the unified L1 cache 245 is transferred simultaneously to the instruction line cache 240 and the IU 215. The instruction line cache 240 uses a pseudo-LRU replacement algorithm. To ensure proper operation in the case of self-modifying code, any writes to the unified L1 cache 245 are checked against the contents of the instruction line cache 240. If a hit occurs in the instruction line cache 240, the appropriate line is invalidated.FIG. 6 depicts the exemplary L1 cache 245 in FIG. 2 in greater detail. It is recalled that the exemplary L1 cache 245 preferably contains 64 Kbytes of data subdivided into 2048 cache lines of 32 bytes each. The L1 cache 245 is also organized as 512 sets, Sets 0-511, that are divided into four ways, Ways 0-3. Blocks 601-604 in L1 cache 245 comprise Ways 0-3, respectively. Ways 1-3, shown in dotted outline, are functionally equivalent to Way 0. This being the case, only Way 0 need be discussed to explain cache hits and cache misses and the retrieval of data from L1 cache 245.Each set consists of eight entries: an address tag and a 32-byte cache line from each of the four ways. For example, if address bits A(13:5) are 000000000, Set 0 is being addressed and, in all four ways, a corresponding 32-byte line in data array 605 and a corresponding address tag in tag array 610 are accessed.Twenty seven physical address bits, A(31:5), are needed to fetch data from the L1 cache 245. Since data are written to, and read from, the L1 cache 245 in entire 32-byte cache lines, the five least significant address bits, A(4:0), are not used. Address bits A(4:0) may be used to address individual bytes within a cache line.Data must be fetched from the L1 cache 245 (and the external L2 cache 404) using physical addresses. Therefore, address translation is necessary. As explained above, address calculation proceeds in two steps, AC1 and AC2. The lowest twelve (12) address bits, A(11:0), are the page offset and are the same in both the linear and physical addresses. These bits do not require translation. The upper twenty bits, A(31:12), of the linear (or logical) address identify the required 4096 byte page and require translation. Since address bits A(11:0) do not require translation, they are available during AC1 for accessing data in L1 cache 245. Address bits A(31:12) are translated during AC2 and translated bits A12 and A13 become available last.The linear (or logical) addresses are translated into physical addresses in a TLB (such as the TLB 230 or TLB 235 of FIG. 2). In one embodiment of the present invention, two TLBs are implemented: a 16 entry direct mapped L1 TLB 230 and a 384 entry 6-way associative L2 TLB 235 (again, both of FIG. 2). Each TLB compares some of linear address bits A(31:12) of the current linear address to linear address bits previously stored in the TLB. If a match is found, the corresponding physical address is output from the TLB to the L1 cache 245 and/or the L2 cache 404.Address bits A(13:5) select a 32-byte line in data array 605 and an address tag in tag array 610 simultaneously in each of the four ways (eight entries total). When a cache line is written into data array 605, the tag address A(31:14), which is a physical address, is simultaneously stored in one of the 512 locations in tag array 610, as determined by the address bits A(13:5). Thus, when address bits A(13:5) are applied to tag array 610, the stored value of tag address A(31:14) is sent to comparator 615 for comparison with address bits A(31:14) of the current physical address. At the same time, the 32 bytes in the data array 605 corresponding to A(13:5) are applied to one of the channels of multiplexer 620.If the address bits A(31:14) are the same, a cache hit has occurred and one (and only one) of the enable signals, WAY 0 HIT, WAY 1 HIT, WAY 2 HIT, or WAY 3 HIT, will go high for the corresponding way. This will, in turn, select the correct channel of multiplexer 620 (which forms a part of sector selection circuitry) and output a corresponding one of the 32-byte lines of data, referred to generically as WAY 0 DATA, WAY 1 DATA, WAY 2 DATA, or WAY 3 DATA.It is noted that two address bits, A13 and A12, must be translated in order to select the correct set in each way. Thus, a first delay is caused by the translation of A13 and A12. A second delay is incurred after translation while the correct set is being selected in tag array 610 (i.e., before the tag address A(31:14) settles at the output of tag array 610). When the tag address A(31:14) is finally valid at the output of tag array 610, another delay is incurred while the tag array 610 output is compared in comparator 615 to the current memory address A(31:14).The present invention improves the rate at which data may be accessed in each of the ways of L1 cache 245 by dividing the L1 cache 245 (and Ways 0-3) into sectors corresponding to predetermined values of A13 and A12. The untranslated physical bits A(11:5), which are available early in AC1, are used to select a set in each sector of the L1 cache 245. The multiple selected sets from the same way are then multiplexed at the data output of the way. The translated physical address bits A13 and A12 control the output multiplexer in each way and thereby select the correct data set (i.e., cache line) to be output from the way. Thus, the speed of the way is more closely related to the rate at which A13 and A12 can be translated, and is not limited by the speed of the tag array 610 and comparator 615.FIG. 7 depicts an improved L1 cache 245 divided into sectors according to one embodiment of the present invention. Once again, only Way 0 (block 601) needs to be shown, since Ways 1-3 are functionally equivalent to Way 0. Tag array 610 and data array 605 are subdivided into four sectors, 0-3, according to the values of A(13:12). When data is written to L1 cache 245, the cache line is stored in a selected one of Data Sectors 0-3 in data array 605 and the tag address A(31:12) is stored in a selected one of Tag Sectors 0-3 of tag array 610. For example, if bits A(13:12) of the translated physical address are 00, the tag address A(31:12) is written into Tag Sector 0 and the corresponding 32-byte cache line is written into Data Sector 0 of data array 605. Similarly, if bits A(13:12) of the translated physical address are 01, 10, or 11, cache lines are written into Data Sectors 1, 2 or 3, respectively, and tag addresses are written into Tag Sectors 1, 2 or 3, respectively.During a read operation, the address bits A(11:5), which do not need to be translated and are available during AC1, are applied to each of the four sectors. Thus, a set is addressed in each of the four sectors. The four corresponding cache lines are output to multiplexer 701 (which forms a part of sector selection circuitry). At the same time, the tag address bits A(31:12) are output from the selected set in each tag sector to a respective first input channel on a respective one of comparators 702-705. The second input channel on each of comparators 702-705 is connected to the address bits A(31:12) of the translated physical address.The address bits A(11:5) are the only bits required to access the caches lines in each of Data Sectors 0-3 and the tag address bits A(31:12) in each of Tag Sectors 0-3. Since address bits A(11:5) do not need translation, they are available during AC1. Therefore, the caches lines from Data Sectors 0-3 are available at the inputs of multiplexer 701 before address bits A13 and A12 are translated. Similarly, the tag address bits A(31:12) from Tag Sectors 0-3 are available at the inputs of comparators 702-705 before address bits A13 and A12 are translated.The address bits A(11:5) can have values only between 0 and 127, thereby addressing any one of 128 possible sets per sector. Nonetheless, the sets in FIG. 7 are shown numbered sequentially from Set 0 to Set 511 across sector boundaries. This is done only for the purpose of illustration. The number of each set shown in FIG. 7 reflects the "offset" value of A13 and A12. For example, Set 0 and Set 384 are both enabled by the set address A(11:5)=0000000. However, Set 384 is only accessed (written to) when A(13:12)=11 and Set 0 is only accessed (written to) when A(13:12)=00.When address bits A13 and A12 are translated during AC2, A13 and A12 immediately select the corresponding channel of multiplexer 701 and the corresponding cache line is output to multiplexer 620. At the same time, translated address bits A(31:12) are applied to comparators 702-705 and, if they match one of the four tag addresses output from the tag sectors, an output line of one of the comparators 702-705 will go high (i.e., a cache hit has occurred). Advantageously, since the A12 and A13 bits from each Tag Sector are always different, only one comparator will go high at time. This allow the outputs to be connected together to form a wired-OR gate. The wired-OR output of comparators 702-705 forms one of the selects, WAY 0 HIT-WAY 3 HIT, on multiplexer 620.As the above description shows, cache lines are output from each way faster because translated address bits A13 and A12 are no longer needed to retrieve the cache line from the data array 605 or retrieve the tag address from the tag array 610. Instead, the translated bits A13 and A12 are used to select a channel in multiplexer 620. This is much faster than selecting a 32-byte cache line from data array 605, which is essentially a (comparatively slow) RAM device. Additionally, the tag addresses are output from the Tag Sectors 0-3 during AC1 and are available for comparison even before the translated physical address bits A(31:12) are sent to comparators 702-705. It is therefore not necessary to wait for the value of the selected tag address to settle and become valid at the tag array 610 output after translation of A13 and A12, because A13 and A12 are no longer required to select a tag address. Hence, the speed of the L1 cache 245 is now closer to the speed at which the address can be translated to a physical address.In a preferred embodiment of the present invention, the values of A13 and A12 assigned to the sectors in the L1 cache 245 may be programmed under the control of the cache unit 204. For example, the physical locations of Sets 0-127 may be programmed to hold tag addresses ending with A(13:12)=00 (Tag Sector 0), A(13:12)=01 (Tag Sector 1), A(13:12)=10 (Tag Sector 2), or A(13:12)=11 (Tag Sector 3). This advantageously allows a processor with a defective cache sector to be salvaged, at the cost of a smaller cache size. For example, if faults are found in Set 50 in Data Sector 0 and in Set 200 in Data Sector 1, Data Sector 3 and Data Sector 4 may be redesignated as Data Sector 0 and Data Sector 1, respectively, according to the value of tag address bit A13. The dysfunctional circuitry used by the old Data Sectors 0 and 1 is no longer accessed and the L1 cache 245 becomes a 32 Kbyte 4-way set associative cache. If three sectors are found to be defective, the remaining good sector is still usable and may contain any value of A13 and A12. The L1 cache 245 then becomes a 16 Kbyte 4-way set associative cache.This redesignation may occur in the factory before sale of the processor 200 in a computer. The processor 200 could then be sold with a less powerful (i.e., smaller) cache at a lower price. In a preferred embodiment, the redesignation of sectors may also occur when a cache error is detected during a self test routine, such as when a computer is booted up. The computer maps out the defective sectors in the cache and continues to run with the smaller cache. Ideally, a warning message is displayed on the monitor warning of the cache fault(s).The redesignation of sectors in the L1 cache 245 may be accomplished by reprogramming switch positions in the data paths that write cache lines into data array 605 and tag address bits A(31:12) into tag array 610. For example, in an initial configuration, cache lines and tags are switched to Sector 3 when A(13:12)=11, to Sector 2 when A(13:12)=10, to Sector 1 when A(13:12)=01, and to Sector 0 when A(13:12)=00 during a cache write operation. If one or both of Sectors 3 and 4 becomes defective, the switching paths may be reconfigured such that cache lines and tags are switched to Sector 1 when A12=1 and to Sector 0 when A12=0 during a write operation. During a read operation, address line A13 is held at 0 on multiplexer 701 so that only Sectors 0 and 1 are selected, depending on the value of A12. The value of A13 in Tag Sectors 0 and 1 may have values of either 0 or 1, however.Although the present invention has been described in detail, those skilled in the art should understand that they can make various changes, substitutions and alterations herein without departing from the spirit and scope of the invention in its broadest form.